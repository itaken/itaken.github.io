<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MySQL 数据库规约, ITAKEN GITHUB PAGES">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MySQL 数据库规约 | ITAKEN GITHUB PAGES</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ITAKEN GITHUB PAGES</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于ITAKEN</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ITAKEN GITHUB PAGES</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于ITAKEN
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/assets/images/202106/01-01.webp')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MySQL 数据库规约</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/mysql/">
                                <span class="chip bg-color">mysql</span>
                            </a>
                        
                            <a href="/tags/%E8%BD%AC%E8%BD%BD/">
                                <span class="chip bg-color">转载</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%BD%AC%E8%BD%BD%E9%AA%8C%E8%AF%81/" class="post-category">
                                转载验证
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-06-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>MySQL</strong> 数据库承载了掌门绝大部分核心业务的<strong>数据存储</strong>，因此 MySQL 数据库的稳定运行至关重要。DBA 团队一直致力于保障数据库环境的平稳运行，编写有掌门 MySQL 数据库规范文档，也提供有掌门数据库查询上线运维平台。<br>规范虽然很全面，但是如果不了解数据库原理，不知道规范带来的效率提升，开发人员并不一定会严格遵守，规范也就失去了意义。</p>
<p>本篇文章旨在从数据库原理出发，从三个角度（<code>建表</code>、<code>索引</code>、<code>SQL 语句</code>）进行深入分析，在了解数据库底层原理的基础上，理解数据库规范、以及数据库优化方法。</p>
<h1 id="一、建表"><a href="#一、建表" class="headerlink" title="一、建表"></a>一、建表</h1><p>如果把 MySQL 数据库实例看作是一个图书馆，数据表就可以看作一本本的书。书名如同表名，概述用途，需要取的易懂且有意义；书本内容过多会选择分册发行，数据表也可以选择分表或者分区。<br>开发人员需要根据实际的业务场景、数据量大小设计不同的表，来满足业务需求。关系型数据库的数据字段后续更改代价较高，因此需要在前期设计阶段就需要考虑用途并设计合理的表结构。优秀的表结构设计，是数据库优化中非常重要的一环。数据表设计需要遵循以下规范要求：</p>
<h2 id="1-字符集"><a href="#1-字符集" class="headerlink" title="1.字符集"></a>1.字符集</h2><p>规范：</p>
<blockquote>
<p>数据库表字符集统一设置为 <code>utf8mb4</code> ，排序规则为 <code>utf8mb4_general_ci</code> 。由于 DBA 已统一按照字符集 utf8mb4 ，排序规则 utf8mb4_general 创建数据库，因此表和字段的字符集可以不再额外设置，保持默认与数据库配置相同即可。</p>
</blockquote>
<p>解析：</p>
<ol>
<li>当字符集或者排序规则不一致时，会导致表<strong>无法关联查询</strong></li>
<li>如果进行字符转换，会导致<strong>索引失效</strong>，而且也会额外消耗数据库性能</li>
<li>统一的字符集和排序规则设置，能减少不必要的字符集问题</li>
</ol>
<pre><code>CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci</code></pre>
<h2 id="2-主键ID"><a href="#2-主键ID" class="headerlink" title="2.主键ID"></a>2.主键ID</h2><p>规范：</p>
<blockquote>
<p>必须创建无符号（ <code>unsigned</code> ）自增（ <code>auto_increment</code> ）整形（ <code>int</code> 或 <code>bigint</code> ）<strong>主键 ID</strong> 字段</p>
</blockquote>
<p>解析：</p>
<ol>
<li>自增主键非常适合 MySQL 数据库聚簇索引数据结构</li>
<li><code>Int</code> 类型长度为 <strong>4 字节</strong>，<code>bigint</code> 为 <strong>8 字节</strong>，数据长度较小，较小的字符类型可减少主键长度（后续在索引章节详解）</li>
<li>无符号相比默认有符号数据量存储可大一倍，无符号 int 类型可存放 42 亿行数据，足够掌门一般应用所需</li>
</ol>
<pre><code>id int unsigned not null auto_increment comment &#39;ID主键’,
primary key(id),</code></pre>
<h2 id="3-必含列"><a href="#3-必含列" class="headerlink" title="3.必含列"></a>3.必含列</h2><p>规范：</p>
<blockquote>
<p>必须包含 <code>deleted</code> ，<code>create_time</code> ，<code>update_time</code> 数据列</p>
</blockquote>
<p>解析：</p>
<ol>
<li>掌门数据系统<strong>禁止物理删除</strong>，应采用逻辑删除方式，并且在代码层维护<strong>标记 deleted 字段</strong></li>
<li>create_time 取记录创建时间，update_time 取记录更新时间，并<strong>由数据库自动维护</strong></li>
<li>创建 create_time，update_time 列索引，以便进行查询</li>
<li>按此规范设计的表，极大的方便BI部门进行增量数据同步，减少同步任务的数据量</li>
</ol>
<pre><code>deleted tinyint not null DEFAULT 0 COMMENT &#39;是否删除 0 未删除 1 删除 默认是0’,
create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;记录创建时间，默认当前时间’,
update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;记录更新时间，默认当前时间’,
index idx_create_time(create_time),
index idx_update_time(update_time),</code></pre>
<h2 id="4-大字段"><a href="#4-大字段" class="headerlink" title="4.大字段"></a>4.大字段</h2><p>规范：</p>
<blockquote>
<p>尽量不要使用 <code>blog</code> 和 <code>text</code> 等大字段</p>
</blockquote>
<p>解析：</p>
<ol>
<li>存储时：<br>实际数据存储在外部存储中，数据列上只存储大字段指针，指向外部存储。大字段在存储时需花费额外 IO 存储实际数据。</li>
<li>查询时：<br>如果列中包含 blog 和 text 列，查询时尽量不要查询该列，不要使用 select * 查询数据<br>查询大字段时需要通过指针找到外部存储，然后再读取字段内容。需要花费额外 IO 读取实际数据。<br>读取的大字段数据只能存放在磁盘中进行后续操作，效率低下。</li>
</ol>
<h2 id="5-行长度，页长度"><a href="#5-行长度，页长度" class="headerlink" title="5.行长度，页长度"></a>5.行长度，页长度</h2><p>规范：</p>
<blockquote>
<p>MySQL 定义行长度不能超过 <code>64KB</code>（不包含 blog ， text 类型）<br>页长度默认为 <code>16KB</code>（由参数 <strong>innodb_page_size</strong> 定义）</p>
</blockquote>
<p>解析：</p>
<ol>
<li>所有列长度总定义不能超过 64KB ，超过后将无法添加新列</li>
<li>当行长度增加，会导致单个页存放的数据行数减少，检索数据需要消耗更多磁盘 IO<br><strong>备注：基于以上行长度和页长度的定义，也许有小伙伴会有疑问，如果表真的存放了 64KB 数据，那岂不是一行数据会占用四个数据页，一个数据页中只能存放一行数据（或一行数据的一部分）。那么此时 MySQL 的 B+ 树的数据存储结构就退变为线性了，这是 MySQL 设计中绝对不允许的！！！</strong><br><strong>按照 MySQL 的 B+ 树设计，一个数据页中至少要存放两行数据，否则 B+ 树会从树状结构退化为线性结构。</strong><br><strong>因此当行存储的实际数据过大，在页中存放不下时，MySQL 在存储这行记录的时候，会将较大的数据列的数据存放在外部存储页中，数据页只保存指向外部存储页的指针。此时如果存储读取这个大的数据列，会额外消耗更多的 IO</strong></li>
</ol>
<h2 id="6-字段类型"><a href="#6-字段类型" class="headerlink" title="6.字段类型"></a>6.字段类型</h2><p>规范：</p>
<blockquote>
<p>根据字段存储内容定义适当的字段类型</p>
</blockquote>
<p>解析：</p>
<ol>
<li>时间类型使用 <code>date</code> 、<code>datetime</code> 或者 <code>timestamp</code> ，不要使用 varchar 或者 int</li>
<li>ID 类型尽量使用 tinyint、smallint、int、bigint，不要使用 varchar</li>
<li>定长字符串尽量使用 <code>char</code>，不要使用 varchar（注意 char 最大定义为 255 ）</li>
<li>字段尽量设置为非空（ <code>not null</code> ），并设置 default 属性</li>
<li>varchar 类型按需定义长度，不要定义过长。<br> 5.1. 字段过长会导致索引长度过长，超过一定长度只能创建前缀索引，而前缀索引不能走到索引覆盖<br> 5.2. 数据读取到内存中是按照定义长度存放，过长的定义会占用更多内存空间</li>
</ol>
<h2 id="7-字段长度"><a href="#7-字段长度" class="headerlink" title="7.字段长度"></a>7.字段长度</h2><p>规范：</p>
<blockquote>
<p>不同字段类型占用的数据存储空间不同，应尽量控制字段在满足业务场景可用的前提下，<strong>长度越短越好</strong></p>
</blockquote>
<p>解析：</p>
<ol>
<li>如果字段可以为空，则需要 1 个字节存放字段是否为空标识</li>
<li>如果字段为 varchar 变长类型，当定义小于 255 字节时，需要 1 字节存放字段长度；当定义超过 255 字节时，需要 2 字节存放字段长度</li>
<li>常见字段类型的长度（以下字段长度均为不为空时的字段长度）<br> 3.1 <code>tinyint</code> 1 字节；<code>smallint</code> 2 字节；<code>int</code> 4 字节；<code>bigint</code> 8 字节；<br> 3.2 <code>date</code> 3 字节；<code>datetime</code> 8 字节；<code>timestamp</code> 4 字节；<br> 3.3 字符类型括号中定义的数字为字符数，即 varchar(32) 可以存放 32 个数字或者汉字<br> 3.4 字符类型长度跟字符集有关（其中 <code>utf8</code> 占用 3 字节，<code>utf8mb4</code> 占用 4 字节）<br>   varchar(10) 类型（utf8mb4）字节数： 10<em>4B+1B=41B<br>   varchar(100)  类型（utf8mb4）字节数：100</em>4B+2B=402B<br>   char(10) 类型（utf8mb4）字节数：10*4B=40B</li>
</ol>
<h1 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h1><p>上文中把数据表比作是一本本的书，那么索引就是好比书本的目录。如果想要快速从书本中提取某项内容，那么查找目录必定是最快捷的。<br>MySQL 的索引是一把双刃剑，一方面能大幅提高查询速度，但同时索引也需要额外的存储，并且索引的维护是有代价的，每一行数据的增删改都需要维护索引信息，因此索引并不是多多益善，而应该按需创建合理的索引。</p>
<h2 id="1-索引目的"><a href="#1-索引目的" class="headerlink" title="1.索引目的"></a>1.索引目的</h2><p>建立索引的目的是为了<strong>减少扫描范围</strong>，提高查询速度。通过索引快速锁定数据范围，返回需要结果。一般情况下，如果单次扫描行数超过数据表总行数的一定比例（预估 10% 左右，官方并没有提供一个确定的数值），查询可能会放弃索引走全表扫描。因此必须要控制查询的数据范围，这也是我一直强调的，如果不能限制数据查询范围，那么所有的优化都是徒劳的。<br>由于数据增删改都会额外维护索引信息，索引过多会降低数据表的 DML 速度，因此只在经常查询并且选择性高的列上创建索引。</p>
<h2 id="2-索引原理"><a href="#2-索引原理" class="headerlink" title="2.索引原理"></a>2.索引原理</h2><p>通过索引(目录)方式，快速提取(查找)需要的记录。<br>MySQL 数据存放在磁盘上，索引结构为 <code>B+ 树</code>，索引即通过 B+ 树实现快速的从磁盘中读取所需要的数据（后面章节会详细介绍 B+ 树结构）<br>生活中随处可见索引的例子，如火车站的车次表、图书的目录、字典的查找等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，来提高检索效率。数据库索引也是类似的原理</p>
<h2 id="3-索引长度"><a href="#3-索引长度" class="headerlink" title="3.索引长度"></a>3.索引长度</h2><p>索引的长度决定不仅决定了索引占用的数据空间大小，也会影响查找数据的 IO 次数。<br>在同等数据量下，索引长度过长会导致单个数据页存放的索引条目数减少，索引高度增加，磁盘 IO 增加，并且索引占用空间增大。所以应该在满足要求的前提下，尽量减少索引长度。</p>
<p>索引的长度限制及计算方式如下：</p>
<ol>
<li>索引<strong>最大长度为 767 字节</strong>，若索引长度超过 767 字节将无法创建（可考虑创建前缀索引）</li>
<li>索引长度与字段定义长度基本相同，前缀索引长度与定义的前缀长度有关</li>
<li>变长类型如 varchar，额外需要 2 个字节存放索引长度</li>
<li>如果字段可以为空，额外需要 1 个字节存放为空标识</li>
<li>索引长度 = 字段长度 + 是否为空(+1) + 是否变长(+2)</li>
</ol>
<p>可通过执行 explain 查看执行计划，key 字段记录查询走哪个索引，key_len 记录所走索引的长度信息</p>
<pre><code>mysql&gt; explain select * from t1 where name like &#39;张三%&#39;;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra                 |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+
|  1 | SIMPLE      | t1    | range | uni_name      | uni_name | 43      | NULL |    1 | Using index condition |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+
1 row in set (0.05 sec)
mysql&gt; show create table t1;
| Table | Create Table
| t1    | CREATE TABLE `t1` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(10) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `cnts` int(11) NOT NULL DEFAULT &#39;1&#39;,
  `a1` varchar(10) DEFAULT NULL,
  `a2` int(11) DEFAULT NULL,
  `a3` varchar(32) DEFAULT NULL,
  `a4` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  `a5` int(11) DEFAULT &#39;1&#39;,
  UNIQUE KEY `uni_name` (`name`),
  KEY `idx_a2` (`a2`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |</code></pre>
<p>如上表中，name 字段索引 uni_name 的 key_len 长度为 43 ，具体长度是按照以下方式计算规则：<br>索引长度 = 字段长度 + 是否为空(+1) + 是否变长(+2)<br>如 name 字段 varchar(10)  可以为空，字符集为 utf8mb4 ，则索引长度为：  10*4B+1B+2B=43B<br>而 a2 字段 int 可以为空，索引长度为：4B+1B=5B</p>
<h2 id="4-聚集索引和非聚集索引"><a href="#4-聚集索引和非聚集索引" class="headerlink" title="4.聚集索引和非聚集索引"></a>4.聚集索引和非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><strong>一个表只能有一个聚集索引</strong>，如果有主键列，则主键列为聚集索引；如果没有主键，有非空唯一列，则以第一个非空唯一列为聚集索引；否则数据库选择内部隐藏 6 字节的 ROWID 作为聚集索引。数据表的数据按照主键的顺序存放，因此对于 MySQL 顺序写入场景下，创建无意义的自增 ID 是最合适的。<br>聚簇索引：物理存储按照聚集索引列排序，聚集索引叶子节点 data 中存放完整行数据。</p>
<h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><strong>一个表可以有多个非聚集索引</strong>，创建聚集索引只为提高查询效率。通过非聚集索引查找的是聚集索引指针信息，还需要通过回表方式查找具体的数据。所谓回表，是指通过普通索引获取到的聚集索引指针信息，再在聚集索引中执行一次 B+ 树查找，获取到最终的行数据。<br>非聚簇索引：非聚集索引列是逻辑排序，与实际数据的物理存储顺序不同。非聚集索引叶子节点 data 中存放聚集索引信息。</p>
<h2 id="5-磁盘-IO-和预读"><a href="#5-磁盘-IO-和预读" class="headerlink" title="5.磁盘 IO 和预读"></a>5.磁盘 IO 和预读</h2><p>MySQL 的数据都是存储在磁盘上的，磁盘的查找方式是怎样的？查询速度怎样呢？如何才能快速的从磁盘中拿到所需要的数据。在介绍 B+ 树之前，我们先了解一下磁盘 IO 和预读机制。</p>
<p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<strong>寻道时间</strong>、<strong>旋转延迟</strong>、<strong>传输时间</strong>三个部分：</p>
<ol>
<li>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 <code>5ms</code> 以下；</li>
<li>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 <code>1/120/2 = 4.17ms</code>；</li>
<li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在<code>零点几毫秒</code>，相对于前两个时间可以忽略不计。</li>
</ol>
<p>那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 <code>5+4.17 ≈ 9ms</code> 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。<br>考虑到磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k ，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6.B+树"></a>6.B+树</h2><p>了解完操作系统的磁盘 IO 和预读机制，我们知道磁盘 IO 是十分耗时的操作，并且一次 IO 拿到的并不是单条数据，而是预读到的操作系统 page 大小的数据（ 4k或者8k ）。<br>而 MySQL 数据库的 page 大小默认为 <code>16k</code> ，即<strong>一次 IO 预读 16k 的数据到数据库的 buffer pool 中</strong>。然后在内存中对数据进行过滤，内存中的数据过滤非常快，与磁盘 IO 时间相比时间可忽略不计。<br>那么好了，如何降低磁盘 IO 是数据库设计优化的重点。而 B+ 树就是为了降低磁盘 IO ，提高数据库查询效率而生。<br>备注：索引树的高度跟磁盘 IO 次数呈正相关，可简单理解为索引树高度即是磁盘 IO 次数。</p>
<p>谈到 B+ 树这个概念前，我们可以稍微了解一下<strong>二叉树</strong>、<strong>平衡二叉树</strong>、<strong>红黑树</strong>，<strong>B 树</strong>，这些树都有不同的数据结构，应用于不同的数据场景。MySQL 数据库选择 B+ 树作为数据存储结构，那么相比其他树，B+ 树有何优势呢？</p>
<p>备注：B+ 树是在 B 树上优化衍生而来，本章节我们主要谈谈 B+ 树与 B 树的区别及优势</p>
<ol>
<li>B 树的非叶子节点会存放数据，导致一个页存放的索引数较少，索引树较高<br>B+ 树的非叶子节点不会存放数据，只存放键值，一个页可以存放更多索引，索引树较矮</li>
<li>B 树的查找可能会在非叶子节点命中，查找不稳定<br>B+ 树的查找必须到叶子节点才会命中，查找十分稳定</li>
<li>B 树的范围遍历效率非常低<br>B+ 树的叶子节点中存放有双向指针构成一种链表结构，范围查询效率非常高效。而数据库的范围查询十分常见<br>因此 B+ 树更加适合作为 MySQL 数据库的数据存储结构，下图是一个 B+ 树的结构图</li>
</ol>
<p><img src="/assets/images/202106/01-01.webp" alt="B+ 树的结构图"></p>
<p><strong>备注：在 MySQL 的 B+ 树结构中，聚簇索引和非聚簇索引存储稍有差异</strong><br>聚簇索引的 data 部分，存储的是具体的行数据<br>非聚簇索引的 data 部分，存储的是主键 ID 信息</p>
<h2 id="7-索引高度"><a href="#7-索引高度" class="headerlink" title="7.索引高度"></a>7.索引高度</h2><p>既然磁盘 IO 是最影响性能的操作，那么优化的目的就是为了减少磁盘 IO 。而索引高度与磁盘 IO 是息息相关的，按照 MySQL 的索引设计，索引的高度就决定了磁盘 IO 的次数。那关于索引的高度，我们需要了解以下其计算规则</p>
<p><img src="/assets/images/202106/01-02.webp" alt="计算规则"></p>
<h2 id="8-索引存储条目数"><a href="#8-索引存储条目数" class="headerlink" title="8.索引存储条目数"></a>8.索引存储条目数</h2><p>很多参考文档都会告诉你，索引的高度一般都在 3-4 层，但到底是 3 层还是 4 层呢？3 层索引和 4 层索引又能存放多少索引量，很多文档又会含糊描述的不清楚。此处我们根据实际例子，来看以下具体的索引能存储多少索引量</p>
<pre><code>假设：表平均行长度为 300B，主键索引列 ID 为 int 类型
          普通索引列 name 为 varchar(20) 类型非空 (utf8mb4)
          普通索引列 info 为 varchar(150) 类型可以为空 (utf8mb4)
分别了解主键索引和普通索引在不同类型下的最大能存储条目数
          主键索引的叶子节点中存放具体行数据；普通索引的叶子节点中存放主键信息

备注：索引存储中除索引信息外，还会用 4B 存储页号，6B 存储其他数据</code></pre>
<h3 id="主键索引-ID（int），索引长度-4B"><a href="#主键索引-ID（int），索引长度-4B" class="headerlink" title="主键索引 ID（int），索引长度 4B"></a>主键索引 ID（int），索引长度 4B</h3><ol>
<li>每个非叶子节点可存放 key 个数为 M1=16KB/(4B+4B+6B)≈1170</li>
<li>每个叶子节点可存放 key 个数为 M2=16KB/(300B+4B+6B) ≈52</li>
<li>则 3 层索引最终能存放最大条目数为：L=1170<em>1170</em>52 ≈7118W</li>
<li>4 层索引最终能存放最大条目数为：L=1170<em>1170</em>1170*52 ≈832亿</li>
</ol>
<h3 id="普通索引-name（varchar-20-），非空，索引长度-20-4B-2B"><a href="#普通索引-name（varchar-20-），非空，索引长度-20-4B-2B" class="headerlink" title="普通索引 name（varchar(20)），非空，索引长度 20*4B+2B"></a>普通索引 name（varchar(20)），非空，索引长度 20*4B+2B</h3><ol>
<li>每个非叶子节点可存放 key 个数为 M1=16KB/(20*4B+2B+4B+6B)≈178</li>
<li>每个叶子节点可存放 key 个数为 M2=16KB/(4B+20*4B+2B+4B+6B) ≈170</li>
<li>则 3 层索引最终能存放最大条目数为：L= 178<em>178</em>170 ≈538W</li>
<li>4 层索引最终能存放最大条目数为：L= 178<em>178</em>178*170 ≈9.58亿</li>
</ol>
<h3 id="普通索引-info（varchar-150-），可为空，索引长度-150-4B-2B-1B"><a href="#普通索引-info（varchar-150-），可为空，索引长度-150-4B-2B-1B" class="headerlink" title="普通索引 info（varchar(150)），可为空，索引长度 150*4B+2B+1B"></a>普通索引 info（varchar(150)），可为空，索引长度 150*4B+2B+1B</h3><ol>
<li>每个非叶子节点可存放 key 个数为 M1=16KB/(150*4B+2B+1B+4B+6B)≈26</li>
<li>每个叶子节点可存放 key 个数为 M2=16KB/(150*4B+2B+1B+4B+6B+4B) ≈26</li>
<li>则 3 层索引最终能存放最大条目数为：L= 26<em>26</em>26 ≈17576</li>
<li>4 层索引最终能存放最大条目数为：L= 26<em>26</em>26*26 ≈456976</li>
<li>5 层索引最终能存放最大条目数为：L= 26<em>26</em>26<em>26</em>26 ≈1188W</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>可以发现当索引长度增加时，会导致每个 page 页存放的索引数减少，索引高度增加。<br>特别是 char/varchar 类型，索引长度会因为 utf8mb4 字符集原因导致索引长度急剧增长，因此需要严格控制字段和索引长度。</p>
<h2 id="9-索引优化"><a href="#9-索引优化" class="headerlink" title="9.索引优化"></a>9.索引优化</h2><p>针对索引的优化，主要在于选择合适的列创建最优的索引，删除无效或者重复索引：</p>
<ol>
<li>列的选择性越高，越适合创建索引。列的选择性计算 count(distinct coumn_name)/count(0)</li>
<li><strong>选择性低的列上不要添加索引</strong>，如 bu，type，status，state，deleted 等列，索引列可能会导致查询效率下降</li>
<li>通过 <code>Show index from table_name</code>，查看表上的索引信息，<strong>cardinality 越大选择性越高</strong></li>
<li>前缀索引。如果索引列太长，可考虑创建前缀索引 <code>index idx_name(column_name(pre_len))</code>  达到 pre_len 的条数，如果达到总条数的 80%  即可</li>
</ol>
<p><strong>备注：前缀索引无法走索引覆盖</strong></p>
<blockquote>
<p>如 lessons 表的 les_uid 字段，定义为<br><code>les_uid</code> varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,<br>但是其实该字段存放的时 uuid 信息，长度为固定的 32 位，该字段如需创建索引，则可考虑前缀索引，指定前缀长度为 32<br><code>index idx_les_uid(les_uid(32))</code>,</p>
</blockquote>
<ol start="5">
<li>组合索引。多列查询条件一起出现，可创建组合索引。并将经常查询列放前面，选择性高的放前面<br>如 <code>index(A,B,C)</code> 相当于建了 index(A,B,C)，index(A,B)，index(A) 三个索引<br>备注：组合索引的列数不宜过多，一般 2-3 列即可。列过多很难用到后面的列，且会增加索引长度。</li>
</ol>
<blockquote>
<p>如经常查询需要查询学生在某一个时间范围的上课信息，可创建基于 stu_id 和 les_start_time 的组合索引<br><code>index idx_stu_id_start_time(stu_id,les_start_time)</code></p>
</blockquote>
<ol start="6">
<li>索引覆盖。当需要查询的列都在索引中，通过扫描索引即可获取所有信息。不需要回表操作，效率较高</li>
</ol>
<pre><code>mysql&gt; explain select count(0) from students where stu_city=&#39;上海市&#39;;
+----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+
| id | select_type | table    | type | possible_keys | key          | key_len | ref   | rows | Extra                    |
+----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | students | ref  | idx_stu_city  | idx_stu_city | 767     | const | 2664 | Using where; Using index |
+----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+
1 row in set (0.06 sec)</code></pre>
<blockquote>
<p>该查询统计行数信息，而 stu_city 列有索引，查询只需要使用 idx_stu_city 扫描即可取得 count 结果，无需回表取其他列数据。<br>extra 列的 using index 表明查询走索引覆盖</p>
</blockquote>
<ol start="7">
<li>索引合并。在 MySQL 5.0 之前，一个表最多只能使用一个索引，从MySQL <strong>5.1</strong> 开始引入索引合并（index_merge）技术优化，对同一个表可以使用多个索引分别进行条件扫描，然后将各自的结果进行合并（<code>intersect</code>/<code>union</code>）。</li>
</ol>
<blockquote>
<p>备注：如果单列索引创建的不合理，比如在 bu、state、status 等列上创建单列索引，当 index_merge 使用到这些列做索引扫描合并，那么查询效率会非常低，需要关注！！！产生这种问题的主要原因是在选择性低的列上创建了索引，选择性低的列不适合创建索引，可能会降低查询效率！！！</p>
</blockquote>
<p><strong>index_merge之using union:</strong></p>
<pre><code>mysql&gt; explain
select count(0)
from lessons
where stu_id=116401
or sel_id=1113;
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+
| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                       |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+
|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL | 1467 | Using union(lessons_stu_id,idx_lessons_sel_id); Using where |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+
1 row in set (0.09 sec)</code></pre>
<blockquote>
<p>查询使用 or 连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取并集(union)</p>
</blockquote>
<p><strong>index_merge之using intersect:</strong></p>
<pre><code>mysql&gt; explain
select count(0)
from lessons
where stu_id=116401
and sel_id=1113;
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                                        |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL |    1 | Using intersect(lessons_stu_id,idx_lessons_sel_id); Using where; Using index |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
1 row in set (0.07 sec)</code></pre>
<blockquote>
<p>查询使用 and 连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取交集(intersect)</p>
</blockquote>
<ol start="8">
<li><strong>重复索引</strong>。重复的索引会需要更多的存储更见和维护代价，可考虑删除重复索引。<br>如索引 <code>index(A)</code> 和 index(A,B) 是重复的，重复的索引需要更多的存储空间和维护代价，可考虑删除 index(A)。</li>
</ol>
<h1 id="三、SQL语句"><a href="#三、SQL语句" class="headerlink" title="三、SQL语句"></a>三、SQL语句</h1><p>前面提到的建表和索引都是数据库优化中的基础，是非常关键的优化点，只有把基础打好，才能在此基础上做更深层次的优化。而 SQL 优化则是上层建筑，是查询的最终表现，通过 SQL 语句的执行计划、扫描行数、查询时间也能直观的反映出查询语句是否优秀。<br>SQL 语句的不同写法，对于底层数据的检索方式有着非常大的差异，也会影响查询方式和最终的数据结果。SQL 优化是在不改变结果的前提下，优化语句，降低扫描数据范围，达到缩短查询时间和扫描行数的目的。如果查询逻辑不合理，无法通过改写 SQL 达到优化的目的，那么则需要考虑调整查询逻辑。</p>
<h2 id="1-执行计划"><a href="#1-执行计划" class="headerlink" title="1. 执行计划"></a>1. 执行计划</h2><p>SQL 语句的执行顺序真实的记录了解释器会如何一步步的执行语句，了解执行计划对于我们分析 SQL 语句，优化语句有非常大的作用<br>我们可以通过 <code>explain</code> + <code>SQL</code> 可以查看语句的<strong>执行计划</strong>。但是执行计划包含的内容太多，如果详细描述，又能整一篇文章了。因此本文只对我们比较关心的地方做重点叙述，简洁而又核心~</p>
<ol>
<li>Id：id 列数字越大越先执行，数字一样则从上而下执行</li>
<li>Type：依次从好到差：<code>system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL</code>，除了 all 之外，其他的 type 都可以使用到索引，如果 type 为 all 就需要关注并优化 SQL 了。</li>
<li>Key：查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个</li>
<li><code>Key_len</code>：处理查询的索引长度，前文中已经介绍过 key_len 的计算规则。ICP 特性使用的索引不会计入</li>
<li>Rows：这里是执行计划中估算的扫描行数，不是精确值</li>
<li>Extra：如果你想要优化你的查询，那就要注意 extra 辅助信息中的 using filesort 和 using temporary ，这两项非常消耗性能，需要注意。</li>
</ol>
<h2 id="2-表关联"><a href="#2-表关联" class="headerlink" title="2. 表关联"></a>2. 表关联</h2><p>MySQL 数据表关联采用 <code>Nested-Loop</code> 方式，又名<strong>嵌套循环</strong>，是 MySQL 中最重要的表关联方式。在 Mysql 8.0 之前，也是仅有的一种表关联方式。想要优化查询语句，对于表关联方式必须要十分清楚。MySQL 在 Nested-Loop Join 的基础上，优化出 Block Nested-Loop Join 关联，两者比较类似。</p>
<h3 id="2-1-Nested-Loop-Join"><a href="#2-1-Nested-Loop-Join" class="headerlink" title="2.1. Nested-Loop Join"></a>2.1. Nested-Loop Join</h3><p>一个简单的嵌套循环联接 (NLJ) 算法一次从循环中的第一个表读取一行，将每一行传递到一个嵌套循环，该循环处理联接中的下一个表。只要还有需要连接的表，这个过程就会重复多次。由于 NLJ 算法每次从外层循环传递一行数据到内存循环，因此循环会重复很多次。</p>
<p><img src="/assets/images/202106/01-03.webp" alt="Nested-Loop Join"></p>
<p>一个简单的 BLJ 算法执行过程如下：</p>
<pre><code>for each row in t1 matching range &#123;
    for each row in t2 matching reference key &#123;
         for each row in t3 &#123;
              if row satisfies join conditions, send to client
         &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-2-Block-Nested-Loop-Join"><a href="#2-2-Block-Nested-Loop-Join" class="headerlink" title="2.2. Block Nested-Loop Join"></a>2.2. Block Nested-Loop Join</h3><p>块嵌套循环 (BNL) 连接算法使用缓冲在外部循环中读取的行，以减少必须读取内部循环中的表的次数，（其中 <strong>join_buffer_size</strong> 参数决定每次读取并放入缓存中的数据量）。例如，如果将 10 行读入一个缓冲区并将该缓冲区传递给下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有 10 行进行比较。这可以将必须读取内部表的次数减少一个数量级。</p>
<p><img src="/assets/images/202106/01-04.webp" alt="Block Nested-Loop Join"></p>
<p>一个 BNL 算法执行过程如下：</p>
<pre><code>for each row in t1 matching range &#123;
    for each row in t2 matching reference key &#123;
        store used columns from t1, t2 in join buffer
        if buffer is full &#123;
           for each row in t3 &#123;
               for each t1, t2 combination in join buffer &#123;
                  if row satisfies join conditions, send to client
               &#125;
             &#125;
            empty join buffer
        &#125;
     &#125;
 &#125;
if buffer is not empty &#123;
   for each row in t3 &#123;
       for each t1, t2 combination in join buffer &#123;
           if row satisfies join conditions, send to client
       &#125;
   &#125;
&#125;</code></pre>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3.总结"></a>2.3.总结</h3><p>不管是 NLJ 或者是优化后的 BNL 算法，都是从驱动表中筛选数据，与被驱动表进行匹配，有以下特性：</p>
<ol>
<li>MySQL 优化器会自动选择小表作为驱动表，以减少循环的次数。但并不会只以表大小作为唯一选择依据</li>
<li>最好不要干涉数据库的驱动表选择，让 MySQL 优化器自动选择最合适的表作为驱动表</li>
<li>查询会首先通过查询条件，过滤驱动表上的数据记录，筛选满足要求的结果放入缓存中。驱动表上需尽量通过索引扫描降低数据量。</li>
<li>被驱动表的关联字段上，需要有索引，否则每一次关联，被驱动表都要全表扫描，效率非常低。</li>
<li>被驱动表的字段类型、字符集、排序方式需和驱动表保持一致，否则无法直接关联</li>
<li>使用外关联时，只有基准表才能被选择为驱动表<br> 如 <code>A LEFT JOIN B ON A.KEY=B.KEY</code> ,则只有 A 表才能被选择为驱动表，B 表不能作为驱动表</li>
</ol>
<h2 id="3-SQL-优化"><a href="#3-SQL-优化" class="headerlink" title="3. SQL 优化"></a>3. SQL 优化</h2><p>SQL 优化的方式方法很多，此处罗列一些比较重要，容易出现问题的优化点：</p>
<ol>
<li>尽量避免全表扫描，应考虑在 <code>where</code> 和 <code>order by</code> 涉及的列上建立索引</li>
<li>被驱动表的关联字段需要创建索引，否则被驱动表会走全表扫描</li>
<li>索引遵循最左前缀匹配原则，<code>like</code> 写法只能将 % 放在右边，如 name like ‘掌门学员%’；若 % 放在左边会导致索引失效</li>
<li>应尽量避免在 where 子句中使用 <code>!= ， &lt;&gt; ，not in</code> 操作符，会导致索引失效</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，可尝试拆分为 union/union all</li>
<li>可考虑使用 <code>join</code>/<code>left join</code> 关联查询，替代子查询、in/not in 的写法，尽量不要用子查询</li>
<li>如果 in 的内容是连续的，可使用 <code>between…and</code> 或者 &gt;….&lt; 替代，改走范围扫描</li>
<li>不要在查询字段上使用函数或者表达式，会导致索引失效，可在参数字段上做函数或表达式运算</li>
<li>查询时需根据字段定义类型进行传参 ，若参数类型与字段定义类型不一致，会导致索引失效</li>
<li>不要使用 <code>select *</code>  写法，只查询需要的列</li>
<li>不要在数据库中使用变量 + 分组排序方式构造排序字段，MySQL 需要基于全量数据做排序分组，效率很低</li>
<li>通过 limit 方式分页会导致后续分页越来越慢，可取前一次分页的最大 ID 作为下一页参数输入，进行分页</li>
<li>不要通过 <code>order by rand()</code> 方式取随机数，效率极低。如果需要取随机数，可以先用随机数方法取得一个整数，然后根据 id&gt;= 该整数即可。</li>
<li>禁止不必要的排序，排序操作极耗资源，不要轻易分组排序</li>
<li>不要在程序中使用 <code>using index</code> 强制索引写法</li>
</ol>
<h2 id="4-SQL-优化示例"><a href="#4-SQL-优化示例" class="headerlink" title="4. SQL 优化示例"></a>4. SQL 优化示例</h2><p>枯燥的知识点，哪有举个例子来的更清晰易懂，本章节我们用具体的例子讲述 SQL 优化的方法跟技巧。</p>
<h3 id="4-1-使用-union-union-all-替换-or-写法"><a href="#4-1-使用-union-union-all-替换-or-写法" class="headerlink" title="4.1. 使用 union/union all 替换 or 写法"></a>4.1. 使用 <code>union</code>/<code>union all</code> 替换 <code>or</code> 写法</h3><p>MySQL 的 or 写法，会导致查询索引失效，而更换为 union/union all 写法，虽然代码长度会增加，但是查询效率会有很大的提升</p>
<pre><code>mysql&gt; explain
select count(0)
from students
where students.created_at&gt;=&#39;2021-05-01&#39;
  or students.referrer_user_id&gt;0;
+----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+
| id | select_type | table    | type | possible_keys              | key  | key_len | ref  | rows     | Extra       |
+----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+
|  1 | SIMPLE      | students | ALL  | created_at,idx_ref_user_id | NULL | NULL    | NULL | 52833786 | Using where |
+----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+
1 row in set (0.06 sec)</code></pre>
<blockquote>
<p>说明：students 表的 created_at 和 referrer_user_id 列都有索引，但是由于查询使用 or 连接，导致无法走索引扫描<br> type 为 all 说明查询走全表扫描，该查询 10min 仍然无法查询出结果</p>
</blockquote>
<p>优化：<br>使用 union/union all 写法代替 or。鉴于 or 的关联记录可能存在重复，使用 union 写法，在外层对结果进行 count</p>
<pre><code>mysql&gt; explain
select count(0)
from
(select id
from students
where students.created_at&gt;=&#39;2021-05-01&#39;
union
select id
from students
where students.referrer_user_id&gt;0) as t;
+------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+
| id   | select_type  | table      | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                    |
+------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+
|    1 | PRIMARY      | &lt;derived2&gt; | ALL   | NULL            | NULL            | NULL    | NULL | 7638172 | NULL                     |
|    2 | DERIVED      | students   | range | created_at      | created_at      | 6       | NULL | 2085176 | Using where; Using index |
|    3 | UNION        | students   | range | idx_ref_user_id | idx_ref_user_id | 4       | NULL | 5552996 | Using where; Using index |
| NULL | UNION RESULT | &lt;union2,3&gt; | ALL   | NULL            | NULL            | NULL    | NULL | NULL    | Using temporary          |
+------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+
4 rows in set (0.24 sec)</code></pre>
<blockquote>
<p>说明：改用 unio 后两个子查询中都能走各自对应的索引，并且因为是查询 ID 信息，查询走覆盖索引 using index，效率很高，该查询最终耗时 11.64s</p>
</blockquote>
<h3 id="4-2-使用-join-关联替换子查询、in、exists-写法"><a href="#4-2-使用-join-关联替换子查询、in、exists-写法" class="headerlink" title="4.2. 使用 join 关联替换子查询、in、exists 写法"></a>4.2. 使用 <code>join</code> 关联替换<code>子查询</code>、<code>in</code>、<code>exists</code> 写法</h3><p>子查询的写法虽然看起来直观清晰，但是子查询是一个独立的查询，不能参与到驱动表的数据过滤，而且子查询的结果数据会被放到临时表中存放，然后与驱动表进行关联，效率非常低。<br>在 Mysql 的写法中，非常不建议子查询写法，而应该尽量用 join 方式替换子查询写法。</p>
<pre><code>mysql&gt; explain
select sum(t.money)
from students
join
(select payments.stu_id,payments.money
from payments
where payments.is_paid=1
  and payments.is_canceled=0
    and payments.money&gt;0) as t on students.id=t.stu_id
    where students.created_at&gt;=&#39;2021-05-01&#39;
      and students.created_at&lt; &#39;2021-06-01&#39;;
+----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+
| id | select_type | table      | type   | possible_keys                     | key     | key_len | ref      | rows    | Extra       |
+----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+
|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL                              | NULL    | NULL    | NULL     | 2805183 | NULL        |
|  1 | PRIMARY     | students   | eq_ref | PRIMARY,created_at                | PRIMARY | 4       | t.stu_id |       1 | Using where |
|  2 | DERIVED     | payments   | ALL    | IDX_MONEY_STU_ID,IDX_MONEY_SEL_ID | NULL    | NULL    | NULL     | 5610366 | Using where |
+----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+
3 rows in set (0.09 sec</code></pre>
<blockquote>
<p>说明：payments 表使用单独的子查询，type 为 ALL 需要扫描整个 payments 表记录，将返回的结果存放在临时表，然后与 students 表进行匹配。查询耗时 22s</p>
</blockquote>
<p>优化：<br>不使用子查询，直接使用 join 进行多表关联，并将查询条件写入到 where 中。</p>
<pre><code>mysql&gt; explain
select sum(payments.money)
from students
join payments on students.id=payments.stu_id
where payments.is_paid=1
  and payments.is_canceled=0
    and payments.money&gt;0
    and students.created_at&gt;=&#39;2021-05-01&#39;
    and students.created_at&lt; &#39;2021-06-01&#39;;
+----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+
| id | select_type | table    | type  | possible_keys                                     | key             | key_len | ref               | rows    | Extra                              |
+----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+
|  1 | SIMPLE      | students | range | PRIMARY,created_at                                | created_at      | 6       | NULL              | 1983818 | Using where; Using index           |
|  1 | SIMPLE      | payments | ref   | payments_stu_id,IDX_MONEY_STU_ID,IDX_MONEY_SEL_ID | payments_stu_id | 4       | forge.students.id |       1 | Using index condition; Using where |
+----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+
2 rows in set (0.26 sec)</code></pre>
<blockquote>
<p>说明：不使用子查询，改为 join 写法后。查询首先根据 students.created_at 走索引扫描，然后根据查询的结果与 payments 表的 stu_id 进行关联。查询耗时 1.85s</p>
</blockquote>
<h3 id="4-3-使用-join-left-join-替代-in-exists、not-in-not-exists-写法"><a href="#4-3-使用-join-left-join-替代-in-exists、not-in-not-exists-写法" class="headerlink" title="4.3. 使用 join/left join 替代 in/exists、not in/not exists 写法"></a>4.3. 使用 <code>join/left join</code> 替代 <code>in/exists、not in/not exists</code> 写法</h3><p>join 写法相当于做等值匹配，可以直接替代大部分场景的 exits 和 in 的写法<br>left join/right join 外关联的写法会以驱动表为母表，被驱动表只包含匹配的数据，配合在 where 条件中添加条件筛选，可用来替代 not exist 和 not in 写法</p>
<pre><code>mysql&gt; explain
select u.id
from users u
where u.updated_at &gt; &#39;2021-05-20 12:00:00&#39;
and u.id not in(select a.user_id from users_account_number a);
+----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+
| id | select_type        | table | type            | possible_keys  | key            | key_len | ref  | rows   | Extra                    |
+----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+
|  1 | PRIMARY            | u     | range           | idx_uptime     | idx_uptime     | 6       | NULL | 103664 | Using where; Using index |
|  2 | DEPENDENT SUBQUERY | a     | unique_subquery | user_id_unique | user_id_unique | 4       | func |      1 | Using index              |
+----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+
2 rows in set (0.06 sec)</code></pre>
<blockquote>
<p>说明：查询是统计 users 表创建时间大于 ‘2021-05-20 12:00:00’，且不在 users_account_number 表中的用户 ID<br>请注意 id=2 的 select_typ 类型为 DEPENDENT SUBQUERY，表示外层 select 结果需要依赖于子查询的结果。效率会非常差</p>
</blockquote>
<p>优化：<br>直接用 join/left join 的写法替代，效率将会有大幅提升</p>
<pre><code>mysql&gt; explain
select u.id
from users u
left join users_account_number a on u.id=a.user_id
where u.updated_at &gt; &#39;2021-05-20 12:00:00&#39;
and a.user_id is null;
+----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+
| id | select_type | table | type   | possible_keys  | key            | key_len | ref          | rows   | Extra                                |
+----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+
|  1 | SIMPLE      | u     | range  | idx_uptime     | idx_uptime     | 6       | NULL         | 105958 | Using where; Using index             |
|  1 | SIMPLE      | a     | eq_ref | user_id_unique | user_id_unique | 4       | zm-user.u.id |      1 | Using where; Not exists; Using index |
+----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+
2 rows in set (0.07 sec)</code></pre>
<blockquote>
<p>说明：查询 select_type 都变为 simple ，并且查询先基于 updated_at 做索引过滤，然后与 users_account_number 进行匹配，效率非常高</p>
</blockquote>
<h3 id="4-4-根据字段类型合理传参"><a href="#4-4-根据字段类型合理传参" class="headerlink" title="4.4. 根据字段类型合理传参"></a>4.4. 根据字段类型合理传参</h3><p>在 MySQL 中，如果参数类型与字段定义类型不一致，会导致查询无法走到索引，这点需要关注。</p>
<pre><code>mysql&gt; explain
    -&gt; select *
from users
where mobile=13999999999;
+----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+
| id | select_type | table | type | possible_keys       | key  | key_len | ref  | rows     | Extra       |
+----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+
|  1 | SIMPLE      | users | ALL  | users_mobile_unique | NULL | NULL    | NULL | 83319185 | Using where |
+----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+
1 row in set (0.08 sec)</code></pre>
<blockquote>
<p>说明：users 表的 mobile 字段是 varchar 类型，并且创建有索引，但是输入参数是整形，导致查询无法走索引扫描，type 为 ALL 全表扫描。</p>
</blockquote>
<p>优化：<br>根据字段类型进行合理的传参，如果 mobile 为 varchar 类型，则在参数上添加引号’’标识为字符类型</p>
<pre><code>mysql&gt; explain
    -&gt; select *
from users
where mobile=&#39;13999999999&#39;;
+----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys       | key                 | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+
|  1 | SIMPLE      | users | const | users_mobile_unique | users_mobile_unique | 62      | const |    1 | NULL  |
+----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+
1 row in set (0.07 sec)</code></pre>
<blockquote>
<p>说明：mobile 字段为 varchar 类型，因此在参数上使用‘’标识为字符类型，查询走到 mobile 列的唯一索引，效率非常高。</p>
</blockquote>
<h3 id="4-5-不要在查询字段上使用函数或表达式"><a href="#4-5-不要在查询字段上使用函数或表达式" class="headerlink" title="4.5. 不要在查询字段上使用函数或表达式"></a>4.5. 不要在查询字段上使用函数或表达式</h3><p>如果在查询字段上使用函数或者表达式，MySQL 会首先对查询字段做函数运算，如果原本是准备基于该字段做索引匹配，函数运算会导致索引失效</p>
<pre><code>mysql&gt; explain
select count(0)
from students
join students_seller on students.id=students_seller.student_id
where date(students.created_at)=&#39;2021-05-05&#39;
 and students_seller.state=0;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
|  1 | SIMPLE      | students        | index | PRIMARY                      | created_at | 6       | NULL              | 52853797 | Using where; Using index           |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
2 rows in set (0.09 sec)</code></pre>
<blockquote>
<p>说明：由于在 students.created_at 字段上使用 date 函数，导致无法通过 created_at 列匹配满足时间要求的数据，通过 rows 列可以看到是全表扫描 5285w 数据量。<br>或许有人会疑问既然是全表扫描，为什么 type 是 index 而不是 ALL。这是因为 students 表只用到 created_at 和 id 列，这两列是直接包含在索引中的，查询是走的覆盖索引。</p>
</blockquote>
<p>优化：<br>不要在查询字段上使用函数，如果需要使用函数，那么函数可以用在参数列上</p>
<pre><code>mysql&gt; explain
select count(0)
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-05-05 00:00:00&#39;
  and students.created_at&lt;=&#39;2021-05-05 23:59:59&#39;
 and students_seller.state=0;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 134092 | Using where; Using index           |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
2 rows in set (0.09 sec)</code></pre>
<blockquote>
<p>说明：由于是查询注册时间为 2021-05-05 日的学生，那么可以替代为使用 created_at&gt;= … and &lt;= 的写法<br>优化后查询根据 students.created_at 走索引范围查询，匹配行数 rows 为 134092 条，然后与 students_seller 表关联，效率非常高。</p>
</blockquote>
<h3 id="4-6-防止分页过大导致查询越来越慢，可使用id优化"><a href="#4-6-防止分页过大导致查询越来越慢，可使用id优化" class="headerlink" title="4.6. 防止分页过大导致查询越来越慢，可使用id优化"></a>4.6. 防止分页过大导致查询越来越慢，可使用id优化</h3><p>在程序开发中，经常会对大量的返回结果进行分页返回展示，但是当分的页数过大，后续的分页查询会越来越慢，例如 limit 100 和limit 1000000,100 的查询效率差别很大。</p>
<pre><code>mysql&gt; explain
select students.id,students.user_id,students_seller.seller_id,students.stu_city
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-01-01&#39;
 and students_seller.state=0
 limit 100;
 -- limit 1000000,100;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 23541528 | Using index condition              |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
2 rows in set (0.43 sec)</code></pre>
<blockquote>
<p>说明：虽然 limit 100 和limit 1000000,100 的解释计划相同，但是执行时间差异非常大。<br>limit m,n 中的 m 数越大，则查询越慢。limit 100 的执行时间 0.05s；limit 1000000,100 的执行时间 35s</p>
</blockquote>
<p>优化：<br>MySQL 更适合于精确查询，如果满足条件的结果很多，是不合理的，应该通过范围限制使得满足条件的结果足够小，最终结果应该控制在 1000 条、100 条甚至 10 条以内。<br>但是如果一定要对大量结果数据分页，那么可以考虑根据 ID 进行适当的范围限制</p>
<pre><code>mysql&gt; explain
select students.id,students.user_id,students_seller.seller_id,students.stu_city
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-01-01&#39;
 and students_seller.state=0
 and students.id&gt;54978976 -- 取上一次分页的最大ID
limit 100;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | PRIMARY    | 4       | NULL              | 26431416 | Using where                        |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+
2 rows in set (0.09 sec)</code></pre>
<blockquote>
<p>说明：例如假设第 10000 页取到的 100 行数据中最大的 students.ID 为 54978976，现在需要取得第 10001 页的 100 行数据<br>那么可以添加 students.id&gt;54978976,然后取 100 行数据，此方法取得的即为第 10001 页的数据。<br>   通过 id 字段的范围限制，比简单的 limit m,n 更加高效，即使是大的数据分页也不会导致效率变低。该方法执行时间稳定为 0.05s</p>
</blockquote>
<h3 id="4-7-where-order-by-limit-查询陷阱"><a href="#4-7-where-order-by-limit-查询陷阱" class="headerlink" title="4.7. where + order by + limit 查询陷阱"></a>4.7. <code>where + order by + limit</code> 查询陷阱</h3><p>在程序设计中，经常需要用到 where+order by+limit 写法获取满足条件的、排序后的 N 条数据结果。这种写法本身并没有问题，但是在实际使用中，这条语句却常常引起严重的性能问题，需要我们重点关注。</p>
<pre><code>mysql&gt; explain
select students.id,students.user_id,students_seller.seller_id,students.stu_city
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-04-05&#39;
 and students.created_at&lt;=&#39;2021-04-05 23:59:59&#39;
 and students_seller.state=0
order by students.updated_at desc
limit 100;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows  | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+
|  1 | SIMPLE      | students        | index | PRIMARY,created_at           | updated_at | 6       | NULL              | 28608 | Using where                        |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |     1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+
2 rows in set (0.08 sec)</code></pre>
<blockquote>
<p>说明：查询是想取得学生注册时间在 2021-04-05 的，并且 state=0 的，按照更新时间取得最近 100 条学生记录。<br>请注意解释计划中得 key 为 updated_at 字段，我们明明是对 created_at 字段做范围限制，为啥 MySQL 选择走 updated_at 列索引？</p>
</blockquote>
<p>敲黑板咯，拿出小本本~<br>当查询语句中包含 <code>where+order by+limit</code> 时<br>由于 MySQL 优化器会认为排序 order by 是非常耗时的操作，如果能在一开始就将结果做排序返回，那是最好的。而且 limit 100 会让优化器认为这 100 条记录是很容易满足的，此时优化器会走如下执行计划：</p>
<ol>
<li>由于 students.updated_at 字段本身就有索引（已排序），按照 updated_at 字段每次取 100 条结果，然后走 where 匹配，将满足的结果返回</li>
<li>重复以上操作，直到有 100 条结果满足要求，循环结束</li>
<li>如果查询按照 students.updated_at 排序的数据经过 where 条件过滤后能快速满足 100 条结果输出，那么查询或许会非常快</li>
<li>但如果一致没有取到满足 where 条件的 100 条结果，会一直循环操作直至遍历 students 整个表！那这个代价是非常恐怖的</li>
</ol>
<p>优化：<br>可以有很多办法避免以上执行计划与预想不一致的情况，本文列举两种办法：<br>方法1.</p>
<blockquote>
<p>order by 的字段调整为与查询条件中的字段一致，但是可能造成结果并非原始期望结果，需要沟通业务部门是否能接受该 SQL 改造。（最优）</p>
</blockquote>
<p>方法2.</p>
<blockquote>
<p>将内部查询使用括号包裹，强制其作为一个先导执行的子查询，然后对子查询的最终结果集进行排序返回。由于子查询中会存放所有满足条件的结果，并且进行文件排序，如果满足条件的结果非常大，该方法会消耗较多资源效率较低。（亦可）</p>
</blockquote>
<p>优化方案1：</p>
<pre><code>mysql&gt; explain
select students.id,students.user_id,students_seller.seller_id,students.stu_city
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-04-05&#39;
 and students.created_at&lt;=&#39;2021-04-05 23:59:59&#39;
 and students_seller.state=0
order by students.created_at desc
limit 100;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 184782 | Using index condition              |
|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
2 rows in set (0.09 sec)</code></pre>
<blockquote>
<p>说明：排序字段修改为与查询字段一致即 students.created_at，由于索引查询本身就是排序的，不必再额外排序，效率非常高。</p>
</blockquote>
<p>优化方案2：</p>
<pre><code>mysql&gt; explain
select t.*
from
(select students.id,students.user_id,students_seller.seller_id,students.stu_city,students.updated_at
from students
join students_seller on students.id=students_seller.student_id
where students.created_at&gt;=&#39;2021-04-05&#39;
 and students.created_at&lt;=&#39;2021-04-05 23:59:59&#39;
 and students_seller.state=0) as t
order by t.updated_at desc
limit 100;
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
|  1 | PRIMARY     | &lt;derived2&gt;      | ALL   | NULL                         | NULL       | NULL    | NULL              | 184782 | Using filesort                     |
|  2 | DERIVED     | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 184782 | Using index condition              |
|  2 | DERIVED     | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |
+----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+
3 rows in set (0.08 sec)</code></pre>
<blockquote>
<p>说明：查询根据 created_at 字段检索满足条件的记录构建为子查询。外层查询结果对子查询进行排序然后取得 100 条记录。<br>此方法不会改变原始业务逻辑，如果满足条件结果集较小，效率很高；但是如果满足条件的中间结果集非常大，则查询效率也会较差</p>
</blockquote>
<h2 id="5-掌门慢SQL优化示例"><a href="#5-掌门慢SQL优化示例" class="headerlink" title="5.掌门慢SQL优化示例"></a>5.掌门慢SQL优化示例</h2><p>上文中讲到的优化办法和优化示例，各位掌门人如能融会贯通，SQL 水平必定能更上一层楼。掌门生产环境中的 SQL 为满足业务功能，可能会关联较多的数据表，写的十分复杂，但是再复杂的查询，也是一个个的 Nested-Loop 关联。按照上述方法改写也能有优化效果，下面就是对掌门线上慢 SQL 的优化示例：</p>
<h3 id="SQL1：数据仓库中优课-BU-的查询服务"><a href="#SQL1：数据仓库中优课-BU-的查询服务" class="headerlink" title="SQL1：数据仓库中优课 BU 的查询服务"></a>SQL1：数据仓库中优课 BU 的查询服务</h3><pre><code>mysql&gt; EXPLAIN SELECT
    count( 0 )
FROM
    `uke_hours`.uke_retire_record rr
    JOIN `uke_hours`.uke_apply_refund_info ari ON rr.apply_refund_id = ari.id
    JOIN `uke`.uke_student stu ON rr.user_id = stu.user_id
    LEFT JOIN `forge`.students students ON students.user_id = ari.stu_user_Id
    JOIN `zm-user`.users users ON rr.user_id = users.id
    LEFT JOIN `forge`.sellers se ON se.user_id = rr.handel_user
    JOIN (
    SELECT
        ard.apply_refund_id
    FROM
        `uke_hours`.uke_apply_refund_detail ard,
        `uke`.uke_class c
    WHERE
        ard.prod_id = c.prod_id
        AND c.is_deleted = 0
    GROUP BY
        ard.apply_refund_id
    ) ard ON rr.apply_refund_id = ard.apply_refund_id
WHERE
    rr.is_new_data = 1
    AND (
        rr.cc_id IN ( 1071853472 )
        OR rr.cr_id IN ( 1071853472 )
    OR rr.team_user_id IN ( 1071853472 )
    OR rr.apply_user_id IN ( 1071853472 ));
+----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+
| id | select_type | table      | type   | possible_keys                                                         | key                         | key_len | ref                       | rows   | Extra                           |
+----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+
|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL                                                                  | NULL                        | NULL    | NULL                      | 145787 | NULL                            |
|  1 | PRIMARY     | rr         | ref    | idx_apply_refund_id,idx_user_id,idx_apply_user_id,idx_cc_id,idx_cr_id | idx_apply_refund_id         | 8       | ard.apply_refund_id       |      1 | Using where                     |
|  1 | PRIMARY     | ari        | eq_ref | PRIMARY                                                               | PRIMARY                     | 8       | ard.apply_refund_id       |      1 | Using where                     |
|  1 | PRIMARY     | se         | eq_ref | sellers_user_id                                                       | sellers_user_id             | 4       | uke_hours.rr.handel_user  |      1 | Using where; Using index        |
|  1 | PRIMARY     | stu        | ref    | idx_userId_isDeleted_unique                                           | idx_userId_isDeleted_unique | 8       | uke_hours.rr.user_id      |      1 | Using index                     |
|  1 | PRIMARY     | students   | eq_ref | user_id                                                               | user_id                     | 4       | uke_hours.ari.stu_user_id |      1 | Using where; Using index        |
|  1 | PRIMARY     | users      | eq_ref | PRIMARY                                                               | PRIMARY                     | 4       | uke_hours.rr.user_id      |      1 | Using where; Using index        |
|  2 | DERIVED     | ard        | ALL    | idx_apply_refund_id,idx_prod_id                                       | NULL                        | NULL    | NULL                      | 145787 | Using temporary; Using filesort |
|  2 | DERIVED     | c          | ref    | idx_prod_version                                                      | idx_prod_version            | 130     | uke_hours.ard.prod_id     |      1 | Using where                     |
+----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+
9 rows in set (0.12 sec),实际执行时间 1.267s</code></pre>
<blockquote>
<p>说明：该查询问题有二。<br>其一，查询中用到子查询，id=2 的 derived 子查询走 type=all 得全表扫描，且因为 group by 语句需要走文件排序操作<br>其二，查询条件使用到 or 条件，并且由于 or 的列太多,查询无法使用索引.只能基于 id=2 中子查询结果驱动整个查询</p>
</blockquote>
<p>优化：</p>
<ol>
<li>想办法用 join 方式将子查询部分改写，不要用子查询。</li>
<li>or 条件中不应该传入 cc_id、cr_id、team_user_id、apply_user_id 多种筛选条件，而应该根据实际传参精确匹配列</li>
<li>可以将 or 条件改写为 union 写法</li>
</ol>
<pre><code>mysql&gt; EXPLAIN SELECT
    count( 0 )
FROM
    `uke_hours`.uke_retire_record rr
    JOIN `uke_hours`.uke_apply_refund_info ari ON rr.apply_refund_id = ari.id
    JOIN `uke`.uke_student stu ON rr.user_id = stu.user_id
    LEFT JOIN `forge`.students students ON students.user_id = ari.stu_user_Id
    JOIN `zm-user`.users users ON rr.user_id = users.id
    LEFT JOIN `forge`.sellers se ON se.user_id = rr.handel_user
    JOIN `uke_hours`.uke_apply_refund_detail ard on rr.apply_refund_id = ard.apply_refund_id
    join `uke`.uke_class c  on ard.prod_id = c.prod_id
       AND c.is_deleted = 0
WHERE
    rr.is_new_data = 1
    AND (
        rr.cc_id IN ( 1071853472 )
        OR rr.cr_id IN ( 1071853472 ) );
+----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+
| id | select_type | table    | type        | possible_keys                                       | key                         | key_len | ref                          | rows | Extra                                         |
+----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+
|  1 | SIMPLE      | rr       | index_merge | idx_apply_refund_id,idx_user_id,idx_cc_id,idx_cr_id | idx_cc_id,idx_cr_id         | 9,9     | NULL                         |    2 | Using union(idx_cc_id,idx_cr_id); Using where |
|  1 | SIMPLE      | ari      | eq_ref      | PRIMARY                                             | PRIMARY                     | 8       | uke_hours.rr.apply_refund_id |    1 | Using where                                   |
|  1 | SIMPLE      | se       | eq_ref      | sellers_user_id                                     | sellers_user_id             | 4       | uke_hours.rr.handel_user     |    1 | Using where; Using index                      |
|  1 | SIMPLE      | ard      | ref         | idx_apply_refund_id,idx_prod_id                     | idx_apply_refund_id         | 8       | uke_hours.rr.apply_refund_id |    1 | NULL                                          |
|  1 | SIMPLE      | c        | ref         | idx_prod_version                                    | idx_prod_version            | 130     | uke_hours.ard.prod_id        |    1 | Using where                                   |
|  1 | SIMPLE      | users    | eq_ref      | PRIMARY                                             | PRIMARY                     | 4       | uke_hours.rr.user_id         |    1 | Using where; Using index                      |
|  1 | SIMPLE      | stu      | ref         | idx_userId_isDeleted_unique                         | idx_userId_isDeleted_unique | 8       | uke_hours.rr.user_id         |    1 | Using index                                   |
|  1 | SIMPLE      | students | eq_ref      | user_id                                             | user_id                     | 4       | uke_hours.ari.stu_user_id    |    1 | Using where; Using index                      |
+----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+
8 rows in set (0.08 sec),实际执行时间 0.033s</code></pre>
<blockquote>
<p>说明：改写后 where 查询中只保留 cc_id 和 cr_id ，由于都是 in 的等值查询，且列上均有索引条件，查询可以使用 index_merge 的优化特性，扫描行数为 2<br>并且查询将子查询写法替换为 join ，使得原本子查询中的全表扫描，变为普通的表关联，查询效率得到极大提升。优化效率 38 倍</p>
</blockquote>
<h3 id="SQL2：market-audit-数据库的查询服务"><a href="#SQL2：market-audit-数据库的查询服务" class="headerlink" title="SQL2：market_audit 数据库的查询服务"></a>SQL2：market_audit 数据库的查询服务</h3><pre><code>mysql&gt; EXPLAIN
SELECT
    ss.id,
    ss.user_id userId,
    ss.scan_state scanCode,
    ss.bu,
    ss.source
FROM
    t_screenshot ss
    LEFT JOIN t_screenshot_analyze sa ON ss.id = sa.screenshot_id
WHERE
    ss.audit_state = 0
    AND ss.re_upload_time IS NULL
    AND ss.bu IN ( 3, 5, 4, 11, 12, 1, 2 )
    AND ((
            ss.re_apply_time IS NOT NULL
            AND ss.re_apply_time &gt;= &#39;2021-05-14 11:30:00.145&#39;
            AND ss.re_apply_time &lt;= &#39;2021-05-21 10:30:00.145&#39; )
            OR ( ss.re_apply_time IS NULL
            AND ss.upload_time &gt;= &#39;2021-05-14 11:30:00.145&#39;
            AND ss.upload_time &lt;= &#39;2021-05-21 10:30:00.145&#39;
        ))
    AND (
    sa.poster_tag != 2
    OR sa.poster_tag IS NULL);
+----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+
| id | select_type | table | type   | possible_keys                                        | key                | key_len | ref                | rows    | Extra                              |
+----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+
|  1 | SIMPLE      | ss    | ref    | idx_create_time,idx_re_upload_time,idx_re_apply_time | idx_re_upload_time | 6       | const              | 1393993 | Using index condition; Using where |
|  1 | SIMPLE      | sa    | eq_ref | PRIMARY                                              | PRIMARY            | 8       | market_audit.ss.id |       1 | Using where                        |
+----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+
2 rows in set (0.07 sec)</code></pre>
<blockquote>
<p>说明：看解释计划似乎查询是走到 <strong>type=ref</strong> 的非唯一索引扫描，实则查询只能根据 ss.re_upload_time IS NULL 这一个条件做简单的非空过滤<br>按照表数据的组成，无异于全表扫描。该查询执行时间 4.87s</p>
</blockquote>
<p>优化：<br>查询中条件基本都无筛选性可言。可以用作筛选条件的就是 re_apply_time 和 upload_time ，但是这个条件在查询中使用 or 连接<br>需要用 <code>union</code> 代替 <code>or</code> 的写法，使查询能分别走到 re_apply_time 和 upload_time 列的索引。</p>
<pre><code>mysql&gt; EXPLAIN
SELECT
    ss.id,
    ss.user_id userId,
    ss.scan_state scanCode,
    ss.bu,
    ss.source
FROM
    t_screenshot ss
    LEFT JOIN t_screenshot_analyze sa ON ss.id = sa.screenshot_id
WHERE
    ss.audit_state = 0
    AND ss.re_upload_time IS NULL
    AND ss.bu IN ( 3, 5, 4, 11, 12, 1, 2 )

    AND ss.re_apply_time IS NOT NULL
            AND ss.re_apply_time &gt;= &#39;2021-05-14 11:30:00.145&#39;
            AND ss.re_apply_time &lt;= &#39;2021-05-21 10:30:00.145&#39;

    AND (
    sa.poster_tag != 2
    OR sa.poster_tag IS NULL)
union
SELECT
    ss.id,
    ss.user_id userId,
    ss.scan_state scanCode,
    ss.bu,
    ss.source
FROM
    t_screenshot ss
    LEFT JOIN t_screenshot_analyze sa ON ss.id = sa.screenshot_id
WHERE
    ss.audit_state = 0
    AND ss.re_upload_time IS NULL
    AND ss.bu IN ( 3, 5, 4, 11, 12, 1, 2 )

    AND ss.re_apply_time IS NULL
            AND ss.upload_time &gt;= &#39;2021-05-14 11:30:00.145&#39;
            AND ss.upload_time &lt;= &#39;2021-05-21 10:30:00.145&#39;
    AND (
    sa.poster_tag != 2
    OR sa.poster_tag IS NULL);
+------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+
| id   | select_type  | table      | type   | possible_keys                                        | key               | key_len | ref                | rows   | Extra                              |
+------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+
|    1 | PRIMARY      | ss         | range  | idx_re_upload_time,idx_re_apply_time                 | idx_re_apply_time | 6       | NULL               |    137 | Using index condition; Using where |
|    1 | PRIMARY      | sa         | eq_ref | PRIMARY                                              | PRIMARY           | 8       | market_audit.ss.id |      1 | Using where                        |
|    2 | UNION        | ss         | range  | idx_create_time,idx_re_upload_time,idx_re_apply_time | idx_create_time   | 5       | NULL               | 178928 | Using index condition; Using where |
|    2 | UNION        | sa         | eq_ref | PRIMARY                                              | PRIMARY           | 8       | market_audit.ss.id |      1 | Using where                        |
| NULL | UNION RESULT | &lt;union1,2&gt; | ALL    | NULL                                                 | NULL              | NULL    | NULL               | NULL   | Using temporary                    |
+------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+
5 rows in set (0.20 sec)</code></pre>
<blockquote>
<p>说明：将 or 连接的条件改为 union 连接，改写后语句长度增加一倍。<br>但是注意到 union 连接的两个子查询，都能根据对应的输入参数（upload_time 和 re_apply_time ），进行索引 <code>range</code> 扫描。<br>基于索引范围的扫描，效率提升很多。该查询执行时间为 0.245s，优化效率提升 20 倍</p>
</blockquote>
<h3 id="SQL3-forge-数据库的分页取数"><a href="#SQL3-forge-数据库的分页取数" class="headerlink" title="SQL3: forge 数据库的分页取数"></a>SQL3: forge 数据库的分页取数</h3><pre><code>mysql&gt; explain
select
  ss.student_id as studentId,
  ss.pre_seller_id as preSellerId,
  ss.state as state
from
  students_seller ss force index(PRIMARY)
where
  ss.bu = 0
  and ss.seller_id is null
order by
  ss.id asc
limit
  115000, 5000;
+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+
|  1 | SIMPLE      | ss    | index | NULL          | PRIMARY | 4       | NULL | 120000 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+
1 row in set (0.05 sec)</code></pre>
<blockquote>
<p>说明：这条 SQL 的逻辑很简单，就是按照 bu=0 和 seller_id is null 作为条件，取得 students_seller 表所有满足条件的记录。<br>由于满足要求的记录较多，该查询可能会循环执行几百次。从慢 SQL 记录中可以看到 2021-05-21 日该查询执行了 721 次，总执行时长 11670s，总扫描行数 363 亿行，返回 360 万行<br>注意：limit 这种写法，解析行数会随着 limit m,n 后的 m 数增加导致解析行数持续增加，查询变慢。</p>
</blockquote>
<p>优化：<br>针对这种循环取数，数据量很大的情况，需要根据 ID&gt;<code>last_max_id</code> 的方式取数<br> 如：上一次循环取到的students_seller表的最大id为102378346</p>
<pre><code>mysql&gt; explain
    -&gt; select
  ss.student_id as studentId,
  ss.pre_seller_id as preSellerId,
  ss.state as state
from
  students_seller ss force index(primary)
where
  ss.bu = 0
  and ss.seller_id is null
    and id&gt;=102378346
order by ss.id asc
limit 5000;
+----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows     | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+
|  1 | SIMPLE      | ss    | range | PRIMARY       | PRIMARY | 4       | NULL | 45237438 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+
1 row in set (0.07 sec)</code></pre>
<blockquote>
<p>说明：按照 id 范围限制后，每次查询时间均非常快速，效率很高。<br>按此方式优化后，每次查询时间稳定为 0.15s，全部扫描 721 次，总执行时长为 108.15s,效率提升 108 倍</p>
</blockquote>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>MySQL 数据库博大精深，只有理解数据库底层原理，才能更好的做好优化工作。因此本文在介绍优化相关的规则和方法时，也会引申介绍相关数据库原理，也是希望帮助大家更好的理解并运用这些优化方法。<br>MySQL 是一个 <code>OLTP</code> 数据库，基于事务的增删改效率很高，基于索引的单值查询也非常快，MySQL 本身也非常适合这种短而快的数据操作或查询。<br>但是多表数据关联查询、查询返回大量数据结果，基于大量数据的统计或者排序操作，并不是 MySQL 数据库所擅长的。倘若不能减少数据扫描范围，那任何查询优化都是空谈。如果是这类 <code>OLAP</code> 数据需求，可以考虑一下其他架构设计，不能完全依赖 MySQL 数据库。</p>
<blockquote>
<p>转载自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GpRX1uEqUz4eRAQpEU3-eg">掌门 MySQL 数据库规约落地及优化实战</a></p>
</blockquote>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Itaken</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://itaken.github.io/2021/6/1/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E7%BA%A6/">https://itaken.github.io/2021/6/1/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E7%BA%A6/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Itaken</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/mysql/">
                                    <span class="chip bg-color">mysql</span>
                                </a>
                            
                                <a href="/tags/%E8%BD%AC%E8%BD%BD/">
                                    <span class="chip bg-color">转载</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="wechat,qq,weibo,linkedin,google,twitter,facebook,qzone,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
        font-size: 18px;
        color: #ff385b;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    
    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">万水千山总是情,打赏一块行不行</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/6/12/git%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="git push失败:&#39;shallow update not allowed&#39;">
                        
                        <span class="card-title">git push失败:&#39;shallow update not allowed&#39;</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-06-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/" class="post-category">
                                    一个问题
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%97%AE%E9%A2%98%E9%9B%86/">
                        <span class="chip bg-color">问题集</span>
                    </a>
                    
                    <a href="/tags/git/">
                        <span class="chip bg-color">git</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/5/29/%E4%BD%BF%E7%94%A8ssh-key%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/">
                    <div class="card-image">
                        
                        <img src="/assets/images/202105/29-01.png" class="responsive-img" alt="github使用ssh key提交代码">
                        
                        <span class="card-title">github使用ssh key提交代码</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" class="post-category">
                                    开发日常
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/github/">
                        <span class="chip bg-color">github</span>
                    </a>
                    
                    <a href="/tags/git/">
                        <span class="chip bg-color">git</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: rgb(255 255 255 / 10%);box-shadow: 0 0 black !important;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, mark'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, mark').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            &copy;
            
                <span id="year">2017-2022</span>
            
            <span id="year">2017</span>
            <a href="/about" target="_blank">Itaken</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/itaken" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:regelhh@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
